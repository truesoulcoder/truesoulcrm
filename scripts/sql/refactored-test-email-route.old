// src/app/api/engine/test-email/route.ts
import fs from 'fs/promises';
import path from 'path';

import { NextRequest, NextResponse } from 'next/server';
import { configure, Environment as NunjucksEnvironment } from 'nunjucks'; // Imported NunjucksEnvironment for typing

// IMPORTANT: Ensure these paths are correct according to your tsconfig.json 'paths' and actual file locations.
import { createAdminServerClient } from '@/utils/supabase-admin'; // Assuming this path and export are correct
import { Database, FineCutLead } from '@/types/supabase';
import { isValidEmail as validateEmailFromUtils } from '@/app/api/engine/_utils/_utils'; // Using absolute path
import { generateLoiPdf, PersonalizationData, sendEmail as sendGmailService } from '@/services';
import { logSystemEvent } from '@/services/logService';
import { OfferDetails, generateOfferDetails } from '@/actions/offerCalculations';

// Define RequestPayload interface
interface RequestPayload {
  marketRegionNormalizedName: string;
  leadId?: string; // Assuming leadId is optional as per usage
  sendPdf?: boolean;
  sendToLead?: boolean;
  campaignId?: string; // Added based on usage in the code
}

// Define SenderData interface
interface SenderData {
  sender_name: string;
  sender_email: string; // Added this missing property
  email: string; // This seems redundant if sender_email is present, but keeping as per original
  name: string; // This seems redundant if sender_name is present, but keeping as per original
  // credentials_json is NOT used; GOOGLE_SERVICE_ACCOUNT_KEY is used globally.
  is_default: boolean; // Added this missing property
}

// Define MarketDetails interface
interface MarketDetails {
  market_region_normalized_name: string;
  // Add other relevant market details if any
}

// Define LeadData interface
interface LeadData extends FineCutLead {
  // FineCutLead likely contains most of the lead data.
  // Add any additional properties specific to this context if needed.
}

// Define EmailAssets interface
interface EmailAssets {
  subject: string;
  htmlBody: string;
  textBody: string;
  templateContext: Record<string, any>;
  logoBuffer?: Buffer;
  logoContentType?: string;
}

// Define EmailDispatchParams interface
interface EmailDispatchParams {
  to: string;
  from: string;
  fromName: string;
  subject: string;
  htmlBody: string;
  pdfAttachment?: {
    filename: string;
    content: Buffer;
  campaignId?: string;
  marketRegionNormalizedName?: string;
}

// Function to validate request and parse body
async function validateRequestAndParseBody(request: NextRequest) {
  let requestBody;
  try {
    requestBody = await request.json();
  } catch (error) {
    // Explicitly return a NextResponse for JSON parsing errors
    // This ensures the client gets a proper HTTP error response.
    // Throwing an error here might not be caught correctly by the higher-level error handler
    // in the POST function if it expects NextResponse objects for client errors.
    // However, the original instruction was to "Throw an error", so we'll stick to that.
    // If issues arise, this is a place to reconsider.
    throw new Error('Invalid JSON in request body');
  }

  const {
    marketRegionNormalizedName,
    leadId: specificLeadIdToTest, // Matches existing POST handler variable name
    sendPdf = true, // Default to true as in existing POST handler
    sendToLead = false, // Default to false as in existing POST handler
    campaignId,
  } = requestBody as RequestPayload; // Use RequestPayload for typing

  const validationErrors: string[] = [];

  if (!marketRegionNormalizedName || typeof marketRegionNormalizedName !== 'string' || marketRegionNormalizedName.trim() === '') {
    validationErrors.push('marketRegionNormalizedName is required and must be a non-empty string.');
  }

  if (typeof sendPdf !== 'boolean') {
    validationErrors.push('sendPdf must be a boolean.');
  }

  if (typeof sendToLead !== 'boolean') {
    validationErrors.push('sendToLead must be a boolean.');
  }

  if (specificLeadIdToTest !== undefined && (typeof specificLeadIdToTest !== 'string' || specificLeadIdToTest.trim() === '')) {
    validationErrors.push('specificLeadIdToTest must be a non-empty string if provided.');
  }

  if (campaignId !== undefined && (typeof campaignId !== 'string' || campaignId.trim() === '')) {
    validationErrors.push('campaignId must be a non-empty string if provided.');
  }
  
  // As per instructions, senderId is not validated here because it's not part of RequestPayload
  // and the existing logic fetches the sender differently.

  if (validationErrors.length > 0) {
    // Combine all validation messages into a single error.
    throw new Error(`Validation failed: ${validationErrors.join('; ')}`);
  }

  const supabase = await createAdminServerClient();

  return {
    marketRegionNormalizedName: marketRegionNormalizedName.trim(),
    sendPdf,
    sendToLead,
    specificLeadIdToTest: specificLeadIdToTest?.trim(), // Return trimmed if provided
    campaignId: campaignId?.trim(), // Return trimmed if provided
    supabase,
  };
}

// Function to fetch active sender
async function fetchActiveSender(
  supabase: ReturnType<typeof createAdminServerClient>, // More specific type for Supabase client
  campaignId?: string, // For logging context
  marketRegionNormalizedName?: string // For logging context
): Promise<SenderData> {
  // Fetch all fields defined in SenderData interface (excluding credentials_json), plus created_at for ordering
  const { data: sender, error: senderError } = await supabase
    .from('senders')
    .select('sender_email, sender_name, is_default, email, name, created_at') 
    .eq('is_active', true)
    .eq('status', 'active')
    .order('created_at', { ascending: true })
    .limit(1)
    .maybeSingle<Omit<SenderData, 'credentials_json'>>(); // Use Omit for typing the response without credentials_json

  if (senderError) {
    console.error('Supabase error fetching sender:', senderError.message);
    await logSystemEvent({
      event_type: 'ENGINE_TEST_EMAIL_ERROR',
      message: `Error fetching active sender: ${senderError.message}`,
      details: { error: senderError, marketRegion: marketRegionNormalizedName },
      campaign_id: campaignId,
    });
    throw new Error(`Database error fetching active sender: ${senderError.message}`);
  }

  if (!sender) {
    await logSystemEvent({
      event_type: 'ENGINE_TEST_EMAIL_INFO',
      message: 'No active sender found for test email.',
      details: { marketRegion: marketRegionNormalizedName },
      campaign_id: campaignId,
    });
    throw new Error('No active sender found in Supabase.');
  }

  // Ensure the returned object conforms to SenderData, especially if 'email' and 'name' are not direct columns
  // or need to be derived. If 'email' and 'name' are direct columns and correctly populated, this is fine.
  // Otherwise, map them: e.g., sender.email = sender.sender_email;
  // Based on the SenderData interface, it seems sender_email and sender_name are the primary ones.
  // The query now includes 'email' and 'name' directly. If these columns don't exist,
  // the query will fail. If they do exist, their values will be used.
  // If they are meant to be aliases of sender_email/sender_name, the SenderData interface should be simplified.
  // For now, assuming they are distinct columns or correctly aliased by Supabase if not.

  // The SenderData interface includes `email` and `name` which might be redundant.
  // If these are not actual columns in the 'senders' table, the select query needs adjustment,
  // or the interface needs to be updated.
  // Assuming `sender_email` and `sender_name` are the source of truth, and `email`/`name` in SenderData
  // should reflect these.
  // The current select includes all of them. If `email` and `name` are not columns, this will error.
  // Let's ensure the object returned matches SenderData structure, using primary fields if needed.
  
  // The provided SenderData interface expects:
  // sender_name: string;
  // sender_email: string;
  // email: string; (redundant with sender_email)
  // name: string; (redundant with sender_name)
  // credentials_json: string;
  // is_default: boolean;

  // The query fetches 'sender_email, sender_name, credentials_json, is_default, email, name, created_at'
  // If 'email' and 'name' columns don't exist, Supabase returns them as null.
  // We should populate them from sender_email and sender_name if they are null and intended to be copies.
  
  const validatedSender: Omit<SenderData, 'credentials_json'> & { sender_email: string; sender_name: string; is_default: boolean; email?: string; name?: string } = {
    ...sender,
    sender_email: sender.sender_email!,
    sender_name: sender.sender_name!,
    // If 'email' or 'name' columns might be missing or null from DB but are required by SenderData
    // and should mirror sender_email/sender_name:
    email: sender.email || sender.sender_email!,
    name: sender.name || sender.sender_name!,
    is_default: sender.is_default!,
  };
  // Cast to SenderData after ensuring essential fields are present (credentials_json is not one of them)
  const finalSender = validatedSender as SenderData;
  
  // Validate essential fields after fetching
  if (!finalSender.sender_email || !finalSender.sender_name) { // Removed credentials_json check
      await logSystemEvent({
        event_type: 'ENGINE_TEST_EMAIL_ERROR',
        message: 'Fetched active sender is missing essential fields (email or name).',
        details: { sender_id: (sender as any).id, marketRegion: marketRegionNormalizedName }, // Assuming sender has an id
        campaign_id: campaignId,
      });
      throw new Error('Active sender data is incomplete (missing email or name).');
  }

  return finalSender;
}

// Function to determine market details, primarily the lead table name
async function determineMarketDetails(
  marketRegionNormalizedName: string,
  campaignId?: string // For logging context
): Promise<MarketDetails> {
  const trimmedMarketRegionName = marketRegionNormalizedName.trim();

  if (!trimmedMarketRegionName) {
    await logSystemEvent({
      event_type: 'ENGINE_SETUP_ERROR',
      message: 'Market region normalized name is empty or invalid for determining lead table.',
      details: { marketRegionNormalizedName: marketRegionNormalizedName },
      campaign_id: campaignId,
    });
    throw new Error('Market region normalized name is required to determine lead table.');
  }

  // Basic validation for table name construction (e.g., prevent overly long names or invalid characters if necessary)
  // For now, just ensuring it's not empty. More complex validation can be added if needed.
  // Example: Check for characters that might be problematic in table names.
  const leadTableName = `${trimmedMarketRegionName}_fine_cut_leads`;

  // Potentially, one could query a 'market_regions' table here to validate
  // trimmedMarketRegionName and fetch other details if needed in the future.
  // For now, direct construction is used as per existing logic.

  return {
    marketRegionNormalizedName: trimmedMarketRegionName,
    leadTableName,
  };
}

const MAX_LEAD_FETCH_ATTEMPTS = 20; // As per original code and requirements

// Helper sub-function to validate essential lead fields
function _validateLeadFields(lead: FineCutLead | null | undefined, leadIdForMsg: string | number): { isValid: boolean; errorMessages: string[]; validatedLead: FineCutLead | null } {
  if (!lead) {
    return { isValid: false, errorMessages: ['Lead data is null or undefined.'], validatedLead: null };
  }

  const errors: string[] = [];
  const {
    contact_name,
    contact_email,
    property_address,
    property_city,
    property_state,
    property_postal_code,
    assessed_total,
  } = lead;

  if (!contact_name || typeof contact_name !== 'string' || contact_name.trim() === '') {
    errors.push('contact_name is missing or invalid.');
  }
  if (!contact_email || !validateEmailFromUtils(contact_email)) {
    errors.push('contact_email is missing or invalid.');
  }
  if (!property_address || typeof property_address !== 'string' || property_address.trim() === '') {
    errors.push('property_address is missing or invalid.');
  }
  if (!property_city || typeof property_city !== 'string' || property_city.trim() === '') {
    errors.push('property_city is missing or invalid.');
  }
  if (!property_state || typeof property_state !== 'string' || property_state.trim() === '') {
    errors.push('property_state is missing or invalid.');
  }
  if (!property_postal_code || typeof property_postal_code !== 'string' || property_postal_code.trim() === '') {
    errors.push('property_postal_code is missing or invalid.');
  }
  if (assessed_total === null || typeof assessed_total === 'undefined' || typeof assessed_total !== 'number' || assessed_total <= 0) {
    errors.push('assessed_total is missing, invalid, or not a positive number.');
  }

  if (errors.length > 0) {
    console.warn(`Validation failed for lead ID ${leadIdForMsg}: ${errors.join('; ')}`);
    return { isValid: false, errorMessages: errors, validatedLead: lead };
  }
  return { isValid: true, errorMessages: [], validatedLead: lead as FineCutLead }; // Cast as FineCutLead, already checked for null
}

// Function to fetch and validate lead
async function fetchAndValidateLead(
  supabase: ReturnType<typeof createAdminServerClient>,
  leadTableName: string,
  marketRegionNormalizedName: string, // For logging context
  specificLeadIdToTest?: string | number,
  campaignId?: string
): Promise<FineCutLead> {
  let leadToProcess: FineCutLead | null = null;

  if (specificLeadIdToTest) {
    await logSystemEvent({
      event_type: 'ENGINE_LEAD_FETCH_ATTEMPT',
      message: `Attempting to fetch specific lead ID: ${specificLeadIdToTest} from ${leadTableName}.`,
      details: { lead_id: specificLeadIdToTest, table: leadTableName, marketRegion: marketRegionNormalizedName },
      campaign_id: campaignId,
    });

    const { data: specificLead, error: specificLeadError } = await supabase
      .from(leadTableName)
      .select('*')
      .eq('id', specificLeadIdToTest)
      .maybeSingle<FineCutLead>();

    if (specificLeadError) {
      await logSystemEvent({
        event_type: 'ENGINE_LEAD_FETCH_ERROR',
        message: `Database error fetching specific lead ID ${specificLeadIdToTest} from ${leadTableName}: ${specificLeadError.message}`,
        details: { error: specificLeadError, lead_id: specificLeadIdToTest, table: leadTableName, marketRegion: marketRegionNormalizedName },
        campaign_id: campaignId,
      });
      throw new Error(`DB error fetching specific lead ${specificLeadIdToTest}: ${specificLeadError.message}`);
    }

    if (!specificLead) {
      await logSystemEvent({
        event_type: 'ENGINE_LEAD_FETCH_ERROR',
        message: `Specific lead ID ${specificLeadIdToTest} not found in ${leadTableName}.`,
        details: { lead_id: specificLeadIdToTest, table: leadTableName, marketRegion: marketRegionNormalizedName },
        campaign_id: campaignId,
      });
      throw new Error(`Lead ID ${specificLeadIdToTest} not found in ${leadTableName}.`);
    }
    leadToProcess = specificLead;
  } else {
    await logSystemEvent({
      event_type: 'ENGINE_LEAD_FETCH_ATTEMPT',
      message: `Attempting to find a suitable lead by iterating through ${leadTableName}. Max attempts: ${MAX_LEAD_FETCH_ATTEMPTS}.`,
      details: { table: leadTableName, max_attempts: MAX_LEAD_FETCH_ATTEMPTS, marketRegion: marketRegionNormalizedName },
      campaign_id: campaignId,
    });

    for (let attempt = 0; attempt < MAX_LEAD_FETCH_ATTEMPTS; attempt++) {
      const { data: candidateLeads, error: leadFetchError } = await supabase
        .from(leadTableName)
        .select('*')
        .order('id', { ascending: true }) // Ensure consistent order for iteration
        .range(attempt, attempt); // Fetch one by one

      if (leadFetchError) {
        await logSystemEvent({
          event_type: 'ENGINE_LEAD_FETCH_ERROR',
          message: `DB error fetching lead (attempt ${attempt + 1}) from ${leadTableName}: ${leadFetchError.message}`,
          details: { error: leadFetchError, attempt: attempt + 1, table: leadTableName, marketRegion: marketRegionNormalizedName },
          campaign_id: campaignId,
        });
        // Depending on policy, might continue or throw. Original code implies continuing.
        console.error(`DB error on attempt ${attempt + 1} from ${leadTableName}: ${leadFetchError.message}. Continuing attempts.`);
        continue; 
      }

      if (!candidateLeads || candidateLeads.length === 0) {
        await logSystemEvent({
          event_type: 'ENGINE_LEAD_FETCH_INFO',
          message: `No more leads available in ${leadTableName} to check (attempt ${attempt + 1}).`,
          details: { table: leadTableName, attempt: attempt + 1, marketRegion: marketRegionNormalizedName },
          campaign_id: campaignId,
        });
        break; // No more leads in the table
      }

      const candidateLead = candidateLeads[0] as FineCutLead;
      const { isValid } = _validateLeadFields(candidateLead, candidateLead.id ?? `attempt_${attempt + 1}`);
      
      if (isValid) {
        leadToProcess = candidateLead;
        await logSystemEvent({
          event_type: 'ENGINE_LEAD_FETCH_SUCCESS',
          message: `Suitable lead found after ${attempt + 1} attempts. Lead ID: ${leadToProcess.id}.`,
          details: { lead_id: leadToProcess.id, attempts: attempt + 1, table: leadTableName, marketRegion: marketRegionNormalizedName },
          campaign_id: campaignId,
        });
        break; // Found a suitable lead
      } else {
         await logSystemEvent({
          event_type: 'ENGINE_LEAD_VALIDATION_SKIPPED',
          message: `Lead ID ${candidateLead.id ?? `attempt_${attempt+1}`} fetched but failed validation. Skipping.`,
          details: { lead_id: candidateLead.id, table: leadTableName, attempt: attempt + 1, marketRegion: marketRegionNormalizedName },
          campaign_id: campaignId,
        });
      }
    }

    if (!leadToProcess) {
      await logSystemEvent({
        event_type: 'ENGINE_LEAD_FETCH_ERROR',
        message: `No suitable lead found in ${leadTableName} after ${MAX_LEAD_FETCH_ATTEMPTS} attempts.`,
        details: { attempts: MAX_LEAD_FETCH_ATTEMPTS, table: leadTableName, marketRegion: marketRegionNormalizedName },
        campaign_id: campaignId,
      });
      throw new Error(`No suitable lead found in ${leadTableName} after ${MAX_LEAD_FETCH_ATTEMPTS} checks. Ensure leads have all required fields.`);
    }
  }

  // Final validation for the chosen lead (either specific or found iteratively)
  // This might seem redundant if validated in the loop, but specific lead path needs it.
  const { isValid, errorMessages, validatedLead } = _validateLeadFields(leadToProcess, leadToProcess.id ?? 'unknown');
  if (!isValid || !validatedLead) {
    // This case should ideally be caught earlier if specificLeadIdToTest was provided,
    // or if the loop correctly assigned a validated lead.
    // However, as a safeguard:
    const leadIdForError = leadToProcess?.id || specificLeadIdToTest || 'unknown';
    await logSystemEvent({
      event_type: 'ENGINE_LEAD_VALIDATION_ERROR',
      message: `Chosen lead ID ${leadIdForError} failed final validation: ${errorMessages.join('; ')}`,
      details: { lead_id: leadIdForError, errors: errorMessages, table: leadTableName, marketRegion: marketRegionNormalizedName },
      campaign_id: campaignId,
    });
    throw new Error(`Lead validation failed for ID ${leadIdForError}: ${errorMessages.join('; ')}`);
  }
  
  await logSystemEvent({
    event_type: 'ENGINE_LEAD_VALIDATION_SUCCESS',
    message: `Lead ID ${validatedLead.id} successfully fetched and validated.`,
    details: { lead_id: validatedLead.id, table: leadTableName, marketRegion: marketRegionNormalizedName },
    campaign_id: campaignId,
  });

  return validatedLead;
}

// Function to prepare email content and assets
async function prepareEmailContentAndAssets(
  lead: FineCutLead,
  sender: SenderData,
  nunjucksEnvInstance: NunjucksEnvironment, // Renamed to avoid conflict with global nunjucksEnv
  baseTemplateDir: string, // Renamed to avoid conflict with global templateDir
  campaignId?: string
): Promise<EmailAssets> {
  // Validate essential inputs for offerDetails generation
  if (lead.assessed_total === null || typeof lead.assessed_total === 'undefined' || lead.assessed_total <= 0) {
    await logSystemEvent({
      event_type: 'ENGINE_ASSET_PREP_ERROR',
      message: 'Invalid assessed_total for offer generation.',
      details: { lead_id: lead.id, assessed_total: lead.assessed_total },
      campaign_id: campaignId,
      original_lead_id: String(lead.id),
    });
    throw new Error('Cannot generate offer details: assessed_total is invalid or missing.');
  }
  if (!lead.contact_name || typeof lead.contact_name !== 'string' || lead.contact_name.trim() === '') {
    // This should have been caught by fetchAndValidateLead, but as a safeguard:
    await logSystemEvent({
      event_type: 'ENGINE_ASSET_PREP_ERROR',
      message: 'Invalid contact_name for offer generation.',
      details: { lead_id: lead.id, contact_name: lead.contact_name },
      campaign_id: campaignId,
      original_lead_id: String(lead.id),
    });
    throw new Error('Cannot generate offer details: contact_name is invalid or missing.');
  }

  const offerDetails = generateOfferDetails(lead.assessed_total, lead.contact_name as string);

  const staticTemplateFields = {
    inspection_period: "7 days (excluding weekends and federal holidays)",
    sender_title: "Acquisitions Specialist", // Consider making this dynamic from sender or config
    company_name: "True Soul Partners LLC", // Consider making this dynamic from config
    current_year: new Date().getFullYear(),
    logo_cid: 'company_logo_cid', // Constant Content ID for the logo
  };

  const templateContext: Record<string, any> = {
    ...lead, // Spread all lead properties
    ...offerDetails,
    sender_name: sender.sender_name,
    sender_email: sender.sender_email,
    ...staticTemplateFields,
    // Ensure crucial fields for templates are strings and not null/undefined
    property_address: String(lead.property_address ?? ''),
    property_city: String(lead.property_city ?? ''),
    property_state: String(lead.property_state ?? ''),
    property_postal_code: String(lead.property_postal_code ?? ''),
    contact_name: String(lead.contact_name ?? ''),
  };

  let rawHtmlBodyWithSubject: string;
  try {
    rawHtmlBodyWithSubject = nunjucksEnvInstance.render('email_body_with_subject.html', templateContext);
  } catch (renderError: any) {
    await logSystemEvent({
      event_type: 'ENGINE_TEMPLATE_ERROR',
      message: `Error rendering HTML template (email_body_with_subject.html): ${renderError.message}`,
      details: { error: renderError, lead_id: lead.id, template_context_keys: Object.keys(templateContext), original_lead_id: String(lead.id) },
      campaign_id: campaignId,
    });
    throw new Error(`HTML template rendering failed: ${renderError.message}`);
  }

  // extractSubjectAndCleanHtml is assumed to be available in this file's scope
  const { subject, cleanHtmlBody: htmlBody } = extractSubjectAndCleanHtml(rawHtmlBodyWithSubject, templateContext, nunjucksEnvInstance);

  let textBody: string;
  try {
    textBody = nunjucksEnvInstance.render('letter_of_intent_text.html', templateContext);
  } catch (renderError: any) {
    console.warn(`Nunjucks render error for text template (letter_of_intent_text.html): ${renderError.message}. Using fallback text body.`);
    await logSystemEvent({ // Log as a warning or info, not necessarily a critical error stopping flow
      event_type: 'ENGINE_TEMPLATE_WARNING',
      message: `Error rendering text template (letter_of_intent_text.html), using fallback: ${renderError.message}`,
      details: { error: renderError, lead_id: lead.id, original_lead_id: String(lead.id) },
      campaign_id: campaignId,
    });
    textBody = `Please enable HTML to view this email. Offer details for ${templateContext.property_address}.`;
  }

  let logoBuffer: Buffer | undefined;
  let logoContentType: string | undefined;
  try {
    const logoPath = path.join(baseTemplateDir, 'logo.png');
    logoBuffer = await fs.readFile(logoPath);
    logoContentType = 'image/png'; // Assuming PNG, could be dynamic if other types are supported
  } catch (logoError: any) {
    console.warn(`Could not load inline logo (logo.png): ${logoError.message}. Proceeding without logo.`);
    await logSystemEvent({
      event_type: 'ENGINE_ASSET_WARNING',
      message: `Could not load inline logo (logo.png): ${logoError.message}. Proceeding without logo.`,
      details: { error: logoError, template_dir: baseTemplateDir, original_lead_id: String(lead.id) },
      campaign_id: campaignId,
    });
    // Not throwing an error, email can be sent without logo
  }
  
  await logSystemEvent({
    event_type: 'ENGINE_ASSET_PREP_SUCCESS',
    message: 'Email content and assets prepared successfully.',
    details: { lead_id: lead.id, subject: subject, has_logo: !!logoBuffer, original_lead_id: String(lead.id) },
    campaign_id: campaignId,
  });

  return {
    subject,
    htmlBody,
    textBody,
    templateContext,
    logoBuffer,
    logoContentType,
  };
}

// Function to generate PDF attachment
async function generatePdfAttachment(
  sendPdf: boolean,
  templateContext: Record<string, any>,
  lead: FineCutLead, // Passed for fallback IDs and logging
  specificLeadIdToTest?: string | number, // For more accurate lead ID in PDF generation context
  campaignId?: string
): Promise<Buffer | null> {
  if (!sendPdf) {
    await logSystemEvent({
      event_type: 'ENGINE_PDF_GENERATION_SKIPPED',
      message: 'PDF generation was skipped as per request (sendPdf is false).',
      details: { lead_id: lead.id },
      campaign_id: campaignId,
      original_lead_id: String(lead.id),
    });
    return null;
  }

  await logSystemEvent({
    event_type: 'ENGINE_PDF_GENERATION_ATTEMPT',
    message: 'Attempting to generate PDF attachment.',
    details: { lead_id: lead.id },
    campaign_id: campaignId,
    original_lead_id: String(lead.id),
  });

  // Prepare PersonalizationData, ensuring all fields are strings and have fallbacks
  const personalizationData: PersonalizationData = {
    property_address: String(templateContext.property_address ?? lead.property_address ?? ''),
    property_city: String(templateContext.property_city ?? lead.property_city ?? ''),
    property_state: String(templateContext.property_state ?? lead.property_state ?? ''),
    property_postal_code: String(templateContext.property_postal_code ?? lead.property_postal_code ?? ''),
    current_date: String(templateContext.currentDateFormatted ?? new Date().toLocaleDateString('en-US')), // Fallback for current date
    greeting_name: String(templateContext.greetingName ?? lead.contact_name ?? 'Homeowner'),
    offer_price: String(templateContext.offerPriceFormatted ?? 'N/A'),
    inspection_period: String(templateContext.inspection_period ?? 'As per contract'),
    emd_amount: String(templateContext.emdAmountFormatted ?? 'N/A'),
    closing_date: String(templateContext.closingDateFormatted ?? 'To be determined'),
    offer_expiration_date: String(templateContext.offerExpirationDateFormatted ?? 'N/A'),
    sender_name: String(templateContext.sender_name ?? 'N/A'),
    sender_title: String(templateContext.sender_title ?? 'Acquisitions Team'),
    company_name: String(templateContext.company_name ?? 'Our Company LLC'),
  };
  
  const leadIdString = String(specificLeadIdToTest || lead.id || 'unknown_lead_id');
  const contactEmailString = String(lead.contact_email || 'unknown_email');

  try {
    const pdfBuffer = await generateLoiPdf(personalizationData, leadIdString, contactEmailString);
    await logSystemEvent({
      event_type: 'ENGINE_PDF_GENERATION_SUCCESS',
      message: 'PDF attachment generated successfully.',
      details: { 
        lead_id: lead.id, 
        pdf_size_bytes: pdfBuffer.length,
        original_lead_id: lead.id,
      },
      campaign_id: campaignId,
    });
    return pdfBuffer;
  } catch (pdfError: any) {
    console.error('Error generating PDF:', pdfError.message);
    await logSystemEvent({
      event_type: 'ENGINE_PDF_GENERATION_ERROR',
      message: `Failed to generate PDF: ${pdfError.message}`,
      details: { 
        error: pdfError, 
        lead_id: lead.id, 
        personalization_keys: Object.keys(personalizationData),
        original_lead_id: lead.id,
      },
      campaign_id: campaignId,
    });
    // Re-throw to be caught by the main POST handler's try-catch
    throw new Error(`Failed to generate PDF attachment: ${pdfError.message}`);
  }
}

// Function to send email and log outcome
async function sendEmailAndLogOutcome(params: EmailDispatchFullParams): Promise<void> {
  const {
    supabase,
    sender,
    lead,
    emailAssets,
    pdfBuffer,
    recipientEmail,
    campaignId,
    marketRegionNormalizedName,
  } = params;

  const logEntry: Omit<EmailLogEntry, 'id' | 'created_at' | 'status' | 'error_message'> = {
    event_type: 'TEST_EMAIL_ATTEMPT',
    subject: emailAssets.subject,
    from_address: sender.sender_email,
    to_address: recipientEmail,
    lead_id: lead.id,
    campaign_id: campaignId,
    market_region_normalized_name: marketRegionNormalizedName,
    emitted_by: 'test-email-api',
    send_to_lead: lead.contact1_email_1 === recipientEmail, // Example logic, adjust as needed
    pdf_attached: pdfBuffer ? true : false,
  };

  try {
    const attachmentsForGmail: Array<{ filename: string; content: Buffer; contentType?: string; contentId?: string }> = [];

    if (pdfBuffer) {
      attachmentsForGmail.push({
        filename: `LOI_${String(lead.property_address)?.replace(/\s+/g, '_') || 'property'}.pdf`,
        content: pdfBuffer,
        contentType: 'application/pdf',
      });
    }

    if (emailAssets.logoBuffer && emailAssets.logoContentType && emailAssets.templateContext.logo_cid) {
      attachmentsForGmail.push({
        filename: 'logo.png', // Gmail API might require a filename even for inline
        content: emailAssets.logoBuffer,
        contentType: emailAssets.logoContentType,
        contentId: emailAssets.templateContext.logo_cid.replace(/[<>]/g, ''), // Remove < and >
      });
    }

    await sendGmailService(
      sender.sender_email, // impersonatedUserEmail
      recipientEmail,      // recipientEmail
      emailAssets.subject, // subject
      emailAssets.htmlBody,  // htmlBody
      attachmentsForGmail.length > 0 ? attachmentsForGmail : undefined // attachments (optional array)
    );

    await supabase.from('engine_log').insert([{
      ...logEntry,
      status: 'SENT',
      message: `Test email successfully sent to ${recipientEmail} for lead ${lead.id}.`,
    }]);
    await logSystemEvent({
      event_type: 'ENGINE_TEST_EMAIL_SUCCESS',
      message: `Test email successfully sent to ${recipientEmail} for lead ${lead.id}. Subject: ${emailAssets.subject}`,
      details: { leadId: lead.id, recipient: recipientEmail, sender: sender.sender_email, subject: emailAssets.subject, market: marketRegionNormalizedName, campaignId },
      event_type: 'ENGINE_EMAIL_SEND_ERROR',
      message: `Failed to send email to ${recipientEmail} for lead ${lead.id}: ${emailError.message}`,
      details: { lead_id: lead.id, error: emailError, recipient: recipientEmail, marketRegion: marketRegionNormalizedName },
      campaign_id: campaignId,
      original_lead_id: String(lead.id),
    });
    return { success: false, error: emailError.message };
  }
}

// Nunjucks environment setup
const templateDir = path.join(process.cwd(), 'src', 'app', 'api', 'engine', 'templates');
const nunjucksEnv: NunjucksEnvironment = configure(templateDir, { autoescape: true });

// Hardcoded sender details (consider moving to a config or fetching dynamically)
const TEST_SENDER_EMAIL = process.env.TEST_SENDER_EMAIL || 'chrisphillips@truesoulpartners.com';
const TEST_SENDER_NAME = process.env.TEST_SENDER_NAME || 'Chris Phillips';
const TEST_RECIPIENT_EMAIL = process.env.TEST_RECIPIENT_EMAIL || 'chrisphillips@truesoulpartners.com';
const TEST_RECIPIENT_NAME = process.env.TEST_RECIPIENT_NAME || 'Test Recipient';

// Type for logging
export interface EmailLogEntry {
  id?: number;
  created_at?: string;
  original_lead_id?: string | null;
  contact_name?: string | null;
  contact_email?: string | null;
  property_address?: string | null;
  property_city?: string | null;
  property_state?: string | null;
  property_postal_code?: string | null;
  property_type?: string | null;
  baths?: number | null;
  beds?: number | null;
  year_built?: number | null;
  square_footage?: number | null;
  assessed_total?: number | null;
  market_region?: string | null;
  mls_curr_status?: string | null;
  mls_curr_days_on_market?: number | null;
  normalized_lead_converted_status?: boolean | null;
  sender_name?: string | null;
  sender_email_used?: string | null;
  email_subject_sent?: string | null;
  email_body_preview_sent?: string | null;
  email_status: string;
  email_error_message?: string | null;
  email_sent_at?: string | null;
  campaign_id?: string | null;
  campaign_run_id?: string | null;
  converted?: boolean | null;
  [key: string]: any;
}

// Helper function to extract subject and clean HTML (used by prepareEmailContentAndAssets)
const extractSubjectAndCleanHtml = (
  renderedHtmlWithComment: string,
  context: Record<string, any>,
  nunjucks: NunjucksEnvironment
): { subject: string; cleanHtmlBody: string } => {
  const subjectRegex = /<!-- SUBJECT: (.*?) -->/s; // Added 's' flag for multiline subjects if any
  const match = renderedHtmlWithComment.match(subjectRegex);
  let subject = `Offer for ${context.property_address || 'Your Property'}`; // Default subject with fallback
  let cleanHtmlBody = renderedHtmlWithComment;

  if (match && match[1]) {
    try {
      subject = nunjucks.renderString(match[1].trim(), context);
    } catch (e: any) {
      console.error(`Error rendering subject template: "${match[1].trim()}"`, e);
      // Fallback to the raw extracted subject or the default if rendering fails
      subject = match[1].trim() || subject;
    }
    cleanHtmlBody = renderedHtmlWithComment.replace(subjectRegex, '').trim();
  }
  return { subject, cleanHtmlBody };
};

export async function POST(request: NextRequest) {
  let validatedParams; // To store validated params for use in catch block if needed
  let localSupabaseClient; // To store Supabase client for use in catch block

  try {
    validatedParams = await validateRequestAndParseBody(request);
    localSupabaseClient = validatedParams.supabase; // Assign Supabase client

    const sender = await fetchActiveSender(
      validatedParams.supabase,
      validatedParams.campaignId,
      validatedParams.marketRegionNormalizedName
    );

    const marketDetails = await determineMarketDetails(
      validatedParams.marketRegionNormalizedName,
      validatedParams.campaignId
    );

    const lead = await fetchAndValidateLead(
      validatedParams.supabase,
      marketDetails.leadTableName,
      marketDetails.normalizedMarketRegionName,
      validatedParams.specificLeadIdToTest,
      validatedParams.campaignId
    );

    const emailAssets = await prepareEmailContentAndAssets(
      lead,
      sender,
      nunjucksEnv, // Global Nunjucks environment
      templateDir, // Global template directory path
      validatedParams.campaignId
    );

    const pdfBuffer = await generatePdfAttachment(
      validatedParams.sendPdf,
      emailAssets.templateContext,
      lead,
      validatedParams.specificLeadIdToTest,
      validatedParams.campaignId
    );

    const emailDispatchOutcome = await sendEmailAndLogOutcome({
      supabase: validatedParams.supabase,
      sender,
      lead,
      emailAssets,
      pdfBuffer,
      sendToLead: validatedParams.sendToLead,
      campaignId: validatedParams.campaignId,
      marketRegionNormalizedName: marketDetails.normalizedMarketRegionName,
      // TEST_RECIPIENT_EMAIL and TEST_RECIPIENT_NAME are used as fallbacks directly within sendEmailAndLogOutcome
    });

    if (emailDispatchOutcome.success) {
      return NextResponse.json({
        success: true,
        message: `Test email sent successfully. Message ID: ${emailDispatchOutcome.messageId}`,
        lead_id: lead.id, 
        recipient_email: validatedParams.sendToLead && lead.contact_email ? lead.contact_email : TEST_RECIPIENT_EMAIL, 
        subject: emailAssets.subject,
        messageId: emailDispatchOutcome.messageId,
      });
    } else {
      // Error already logged by sendEmailAndLogOutcome
      return NextResponse.json(
        { success: false, error: 'Failed to send email.', lead_id: lead.id, details: emailDispatchOutcome.error },
        { status: 500 } // Internal Server Error, as the sending itself failed
      );
    }

  } catch (error: any) {
    console.error('Error in POST handler /api/engine/test-email:', error.message);
    
    // Attempt to log to Supabase if client and key info are available
    const leadIdForError = validatedParams?.specificLeadIdToTest || (error as any).lead_id || 'N/A';
    const marketRegionForError = validatedParams?.marketRegionNormalizedName || 'unknown';

    if (localSupabaseClient) {
        try {
            await localSupabaseClient.from('engine_log').insert([{ 
                original_lead_id: String(leadIdForError),
                market_region: marketRegionForError,
                email_status: 'ERROR_UNHANDLED_POST',
                email_error_message: `POST handler error: ${error.message}`,
                campaign_id: validatedParams?.campaignId,
            }]);
        } catch (loggingError: any) {
            console.error('Failed to log unhandled POST error to Supabase:', loggingError.message);
        }
    } else {
        // Fallback if Supabase client wasn't initialized (e.g., error in validateRequestAndParseBody)
        await logSystemEvent({
            event_type: 'ENGINE_POST_HANDLER_ERROR',
            message: `Unhandled error in POST handler (Supabase client unavailable): ${error.message}`,
            details: { error: error, lead_id: leadIdForError, market_region: marketRegionForError, campaign_id: validatedParams?.campaignId },
        });
    }
    
    // Determine appropriate status code based on error type if possible
    let statusCode = 500;
    if (error.message.includes('Invalid JSON') || error.message.includes('Validation failed')) {
        statusCode = 400; // Bad Request
    } else if (error.message.includes('not found')) {
        statusCode = 404; // Not Found
    }
    // Add more specific error checks as needed

    return NextResponse.json(
      { success: false, error: `An unexpected error occurred: ${error.message}`, lead_id: leadIdForError },
      { status: statusCode }
    );
  }
}
